# 🌀 Wake Lang

> The live scripting language of the **Wake JIT Engine** — designed for instant execution, modularity, and creativity.

---

### ⚙️ Overview
Wake Lang is a lightweight, C-based scripting language built to run **instantly** inside the [Wake JIT Engine](https://github.com/wake-tools/Wake).  
It allows live execution, rapid prototyping, and direct interaction with native libraries — no compilation delay, no overhead.

---

### 🚀 Highlights
- **Real-time execution** — scripts compile and run instantly.  
- **C99 syntax** — familiar, minimal, and powerful.  
- **Modular runtime** — directly integrated with Wake Tools and Wake Packages (.wpkg).  
- **Cross-platform** — Windows, Linux, and macOS.  

---

### 🧩 Ecosystem
- 🔹 [Wake JIT Engine](https://github.com/wake-tools/Wake) — the runtime powering Wake Lang  
- 🔹 [Wake Tools](https://github.com/wake-tools/Wake-Tools) — standard packages and utilities  
- 🔹 [Wake Lang Wiki](https://github.com/wake-tools/Wake-Lang/wiki) — full reference and examples  

---

### 🔹 Core Syntax (currently implemented)

| Symbol | Purpose | Description |
|:-------:|:---------|:-------------|
| `>` | Sequence | Runs commands in order (waits for completion). |
| `\|` | Parallel | Runs commands simultaneously. |
| `{}` | Variables | Dynamic placeholders using JSON-like nodes. |

---

### 🔹 Execution Metadata

| Tag | Purpose | Description |
|:----:|:---------|:-------------|
| `<:jit:>` | JIT Block | Defines how the file is compiled and executed in Wake. |
| `w32 \| w64` | Target | Indicates 32-bit or 64-bit platform targets. |
| `{this.file}` | Source Reference | Refers to the current `.jc` file being executed. |
| `{jit.file}` | Output Reference | Refers to the JIT-compiled binary file generated by Wake. |
| `#Jit.reload` | Reload Directive | Reloads and executes the compiled code instantly. |

> 🧩 *Execution metadata defines the bridge between Wake Lang scripts and the Wake Runtime — it’s what makes each file self-executable.*

---

### 💡 Typical language from
```c
build | build > run
```

### 💡 Minimal example
```c
/*|------------------------------------------------------------>>
  | run: wake > hello.jc
  |------------------------------------------------------------>>
    <:jit:w32|w64>
        {wk.module.sys.r}wake-tools/tcc-v0.1w/tcc
            -xc -shared {this.file}
            -o {jit.file}
        >
        #Jit.reload
    <:/jit:>
  |------------------------------------------------------------>>
*/
#include <stdio.h>

int main(void) {
    printf("Hello, Wake!\n");
    return 0;
}
```

> Run it instantly inside the Wake environment, no build step required.


---

### 🔹 Built-in Variables List

Wake Lang exposes several **core environment variables** that provide context about the runtime, build system, and file paths.  
They make scripts **portable and self-adaptive**, automatically resolving to the correct directories depending on the platform and mode.

| Variable | Description | Example Output |
|:----------|:-------------|:----------------|
| `{wk.include}` | Absolute path to the include directory for Wake headers and packages. | `wake/runtime/include/` |
| `{wk.libs}` | Absolute path to the Wake runtime libraries. | `wake/runtime/libs/` |
| `{wk.module}` | Absolute path to the Wake system modules. | `wake/runtime/module/` |
| `{wk.module.sys.r}` | Absolute path to the Wake system modules in **release mode**. | `wake/runtime/module/w64-r/` |
| `{wk.module.sys.d}` | Absolute path to the Wake system modules in **debug mode**. | `wake/runtime/module/w64-d/` |
| `{build.sys}` | Current build system name derived from the Wake executable type. | `win64` |
| `{build.sys.r}` | Build system identifier for **release mode**. | `win64-r` |
| `{build.sys.d}` | Build system identifier for **debug mode**. | `win64-d` |
| `{this.file}` | Reference to the current `.jc` file being executed. | `samples/hello.jc` |
| `{jit.file}` | Reference to the JIT-compiled binary generated by Wake. | `samples/hello.dll` |

> 🧩 *These variables are automatically provided by the Wake runtime and resolved before command execution. They ensure scripts remain consistent across environments, architectures, and build modes.*

---
